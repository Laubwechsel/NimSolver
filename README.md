# NimSolver
Solving a game of Nim using a Min-Max Algorithm
## The Rules
- Two player A and B play a game of Nim
- There is one pile of coins from witch a player takes 1 to 3 coins, then its the next players turn
- The player taking the last coin wins
- Player A goes first
## Algorithms
Testing was done on a Surface pro 6
### Building The Tree
To run a Min-Max algorithm, a decision tree has to be build.<br>
the nodes of the tree represent a turn and contain information on:
1. the current turn player
2. the amount of coins left
3. their value in the Min-Max algorithm
#### Full Tree
The naive approach to building the decision tree is to spawn 3 child nodes  every node containing the opponents turn and 1 to 3 less coins.<br>
But this leads to an exponential increas of the number of nodes in the tree, which can quickly lead to the programm running out of memory.

#### Approximate number of Nodes
x = amount of nodes<br>
n = amount of coins<br>

  
  $$ \text{approximate number of nodes } x = 3^{a*n-4+b}+1 $$


#### Space Complexity

  
 $$ \text{Space Complexity } \upomicron(3^n)$$


#### Memorized Tree
Since many nodes generated by the naive approach represent the same gamestate we can instead remember all nodes previously generated and when we would generate a node with an equal gamestade, use the existing node.<br>
this reduces the amount of nodes in the tree

#### Approximate number of Nodes
x = amount of nodes<br>
n = amount of coins<br>

  
$$ x = 2n -2 \text{ for }n>6 $$


#### Space Complexity

$$ \text{Space Complexity } \upomicron(n)$$

### Calculating Node Values
To reach a result in the minmax algorithm, each node has to be given a value, which represents its favorability for one party to win
#### Recursive
with the recursive approach the Calculate value function on the Root Node is executed.<br>
the CalculateValue method either returns the value 1 if player A would win or -1 if player B would win.<br>
otherwise the CalculateValue method of each child is executed and their results added together.
Since each coin (after the fifth) increases the depht of the decision tree by one sthe call stack also increases by one, eventually leading to a a stack overflow.
#### Itterative
To solve the stack overflow problem a itterative approach can be used.<br>
If the parent of a node is known, the tree can be walked untill a node has no children or all the childrens values have been determined, the nodes value is then determined.<br>
Or if the Array created during the memorized approach is still available and assuming the index of a node is its remaining coin count, the nodes in indexes 1-3 are given the value of the victor, then the remaining nodes are given the value of the sum of their children in ascending order.
### Displaying The Result
When presenting the results the programm will announce who will win and which would be the optimal moves for each player
#### String Concatination
simply concatinating the string instead of calling Console.Write for each node in the path delivers slight performance improvements, but at around 10^5 coins performance problems can be noticed
#### String Builder
Using a StringBuilder improves the performance massively, to the point that it takes longer for the consol to display the entire path than it takes the program to build the string
